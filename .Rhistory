x <- matrix(rep(0, nvar*nTs), nrow=nvar, ncol=nTs)
cp_x <- matrix(rep(0, nvar*nTs), nrow=nvar, ncol=nTs)
for (t in 1: nTs){
x[,t] <- (a_jf %*% theta_nf[person,] + d[,t]) # iterate for each threshold for a person
# convert it to cum. probabilities
# per GRM's model (Samejima, 1969) P(x>=0) = 1, P(x >= k+1) = 0
# P(x>=1) > P(x >= 2) >...> P(x >= k)
cp_x[,t] <-  pnorm(x[,t], 0, 1, lower.tail = FALSE) # lower.tail should be FALSE
}
# x_jk (incorporating theta value in the term) for person i
x_jk <- t(x) # will iterate for 1 person and all thresholds and items at a time
# cumulative probabilities for 1 person, all thresholds, and all items
# but I must add the prob. of item category >= k, P(x >= k) = 0
# to avoid error at min(which()) below
cp_x_jk <- t(cbind(cp_x, 0))
# select a probability from a uniform distribution
# approach 1: using U(0,1); i.e., uniform dist. from 0 and 1
if (method == "U"){
q_u <- runif(nvar, 0, 1) # this equals punif(q_u, 0, 1, lower.tail = TRUE)
p <- punif(q_u, 0, 1, lower.tail = FALSE)
} else if (method == "N"){ # approach 2: using N(0,1); i.e., standard normal dist.
q_n <- rep(rnorm(1, 0, 1), nvar)
p <- pnorm(q_n, 0, 1, lower.tail = FALSE)
}
# categorize the underlying variables
for (item in 1: nvar){
cat_grm2[person,item] <- min(which(cp_x_jk[,item] <= p[item]))
}
} # END iterations for all persons
# for binary response
if (nTs == 1){
cat_grm2[cat_grm2==1] <- 0
cat_grm2[cat_grm2==2] <- 1
}
# check response probabilities per replication
res_prob_tb <- NULL
for (item in 1:nvar){
res_prob <- table(cat_grm2[,item])
res_prob_tb <- rbind(res_prob_tb, res_prob)
}
res_prob_tb_WR <- cbind(Rep = r,
item=seq(1,nvar),
res_prob_tb/rowSums(res_prob_tb))
res_prob_tb_BR2 <- rbind(res_prob_tb_BR2, res_prob_tb_WR)
# end checking response probabilities per replication
# write data out per each replication
write.table(cat_grm2,
paste0(file_dir, "/", file_prefix, "_grm2_rep", r, ".dat"),
row.names = FALSE,
col.names = FALSE,
quote = FALSE)
# compile a list of rep names ####
rep_name <- paste0(file_prefix, "_grm2_rep", r, ".dat")
rep_list3 <- rbind(rep_list3, rep_name)
# write it out
write.table(rep_list3,
paste0(file_dir, "/", file_prefix, "_grm_replist.dat"),
row.names = FALSE,
col.names = FALSE,
quote = FALSE)
} # END DATA REPLICATION
# response probability average over all items and replications
last_col <- ncol(res_prob_tb_BR2)
start_col <- 3
x <- res_prob_tb_BR2[,start_col:last_col]
n <- nrow(x)
avg_res_prob <- apply(x, MARGIN = 2, function(x) FUN = sum(x)/n)
# write theta values out ####
write.csv(theta_values,
paste0(file_dir, "/", file_prefix, "_dsrep_theta.csv"),
row.names = FALSE)
theta_values <- theta_matrix
nTs <- ncol(d) # n of thresholds
# arrange item discrimination in a p x m form,
# p = max n. of items, m = max n. of factors
df <- matrix(rep(0, length(a)), nrow=length(a), ncol=length(model))
param <- a
f <- 1
for (f in 1:length(model)){
start_n <-   min(unlist(model[f]))
end_n <- max(unlist(model[f]))
for (j in start_n : end_n){
df[j,f] <- param[j]
}
}
a_jf <- df
# SIMULATE DATA SET FROM 1 TO R
rep_list3 <- NULL
res_prob_tb_BR2 <- NULL
# convert theta_nf to type of data frame for valid indexing when dim = 1
if(length(model)==1){
theta_nf <- as.data.frame(theta_values)
} else if (length(model)>1){
theta_nf <- theta_values
}
for (r in 1:R){
# data set using probability
# if (sim_methods=="grm2" | sim_methods=="all"){
cat_grm2 <- matrix(rep(0, N*nvar), nrow=N, ncol=nvar)
person <- 1
for (person in 1:N){
x <- matrix(rep(0, nvar*nTs), nrow=nvar, ncol=nTs)
cp_x <- matrix(rep(0, nvar*nTs), nrow=nvar, ncol=nTs)
for (t in 1: nTs){
x[,t] <- (a_jf %*% theta_nf[person,] + d[,t]) # iterate for each threshold for a person
# convert it to cum. probabilities
# per GRM's model (Samejima, 1969) P(x>=0) = 1, P(x >= k+1) = 0
# P(x>=1) > P(x >= 2) >...> P(x >= k)
cp_x[,t] <-  pnorm(x[,t], 0, 1, lower.tail = FALSE) # lower.tail should be FALSE
}
# x_jk (incorporating theta value in the term) for person i
x_jk <- t(x) # will iterate for 1 person and all thresholds and items at a time
# cumulative probabilities for 1 person, all thresholds, and all items
# but I must add the prob. of item category >= k, P(x >= k) = 0
# to avoid error at min(which()) below
cp_x_jk <- t(cbind(cp_x, 0))
# select a probability from a uniform distribution
# approach 1: using U(0,1); i.e., uniform dist. from 0 and 1
if (method == "U"){
q_u <- runif(nvar, 0, 1) # this equals punif(q_u, 0, 1, lower.tail = TRUE)
p <- punif(q_u, 0, 1, lower.tail = FALSE)
} else if (method == "N"){ # approach 2: using N(0,1); i.e., standard normal dist.
q_n <- rep(rnorm(1, 0, 1), nvar)
p <- pnorm(q_n, 0, 1, lower.tail = FALSE)
}
# categorize the underlying variables
for (item in 1: nvar){
cat_grm2[person,item] <- min(which(cp_x_jk[,item] <= p[item]))
}
} # END iterations for all persons
# for binary response
if (nTs == 1){
cat_grm2[cat_grm2==1] <- 0
cat_grm2[cat_grm2==2] <- 1
}
# check response probabilities per replication
res_prob_tb <- NULL
for (item in 1:nvar){
res_prob <- table(cat_grm2[,item])
res_prob_tb <- rbind(res_prob_tb, res_prob)
}
res_prob_tb_WR <- cbind(Rep = r,
item=seq(1,nvar),
res_prob_tb/rowSums(res_prob_tb))
res_prob_tb_BR2 <- rbind(res_prob_tb_BR2, res_prob_tb_WR)
# end checking response probabilities per replication
# write data out per each replication
write.table(cat_grm2,
paste0(file_dir, "/", file_prefix, "_grm2_rep", r, ".dat"),
row.names = FALSE,
col.names = FALSE,
quote = FALSE)
# compile a list of rep names ####
rep_name <- paste0(file_prefix, "_grm2_rep", r, ".dat")
rep_list3 <- rbind(rep_list3, rep_name)
# write it out
write.table(rep_list3,
paste0(file_dir, "/", file_prefix, "_grm_replist.dat"),
row.names = FALSE,
col.names = FALSE,
quote = FALSE)
} # END DATA REPLICATION
# response probability average over all items and replications
last_col <- ncol(res_prob_tb_BR2)
start_col <- 3
x <- res_prob_tb_BR2[,start_col:last_col]
n <- nrow(x)
avg_res_prob <- apply(x, MARGIN = 2, function(x) FUN = sum(x)/n)
# write theta values out ####
write.csv(theta_values,
paste0(file_dir, "/", file_prefix, "_dsrep_theta.csv"),
row.names = FALSE)
theta_values <- theta_matrix
nTs <- ncol(d) # n of thresholds
# arrange item discrimination in a p x m form,
# p = max n. of items, m = max n. of factors
df <- matrix(rep(0, length(a)), nrow=length(a), ncol=length(model))
param <- a
f <- 1
for (f in 1:length(model)){
start_n <-   min(unlist(model[f]))
end_n <- max(unlist(model[f]))
for (j in start_n : end_n){
df[j,f] <- param[j]
}
}
a_jf <- df
# SIMULATE DATA SET FROM 1 TO R
rep_list3 <- NULL
res_prob_tb_BR2 <- NULL
# convert theta_nf to type of data frame for valid indexing when dim = 1
if(length(model)==1){
theta_nf <- as.data.frame(theta_values)
} else if (length(model)>1){
theta_nf <- theta_values
}
for (r in 1:R){
# data set using probability
# if (sim_methods=="grm2" | sim_methods=="all"){
cat_grm2 <- matrix(rep(0, N*nvar), nrow=N, ncol=nvar)
person <- 1
for (person in 1:N){
x <- matrix(rep(0, nvar*nTs), nrow=nvar, ncol=nTs)
cp_x <- matrix(rep(0, nvar*nTs), nrow=nvar, ncol=nTs)
for (t in 1: nTs){
x[,t] <- (a_jf %*% theta_nf[person,] + d[,t]) # iterate for each threshold for a person
# convert it to cum. probabilities
# per GRM's model (Samejima, 1969) P(x>=0) = 1, P(x >= k+1) = 0
# P(x>=1) > P(x >= 2) >...> P(x >= k)
cp_x[,t] <-  pnorm(x[,t], 0, 1, lower.tail = FALSE) # lower.tail should be FALSE
}
# x_jk (incorporating theta value in the term) for person i
x_jk <- t(x) # will iterate for 1 person and all thresholds and items at a time
# cumulative probabilities for 1 person, all thresholds, and all items
# but I must add the prob. of item category >= k, P(x >= k) = 0
# to avoid error at min(which()) below
cp_x_jk <- t(cbind(cp_x, 0))
# select a probability from a uniform distribution
# approach 1: using U(0,1); i.e., uniform dist. from 0 and 1
if (method == "U"){
q_u <- runif(nvar, 0, 1) # this equals punif(q_u, 0, 1, lower.tail = TRUE)
p <- punif(q_u, 0, 1, lower.tail = FALSE)
} else if (method == "N"){ # approach 2: using N(0,1); i.e., standard normal dist.
q_n <- rep(rnorm(1, 0, 1), nvar)
p <- pnorm(q_n, 0, 1, lower.tail = FALSE)
}
# categorize the underlying variables
for (item in 1: nvar){
cat_grm2[person,item] <- min(which(cp_x_jk[,item] <= p[item]))
}
} # END iterations for all persons
# for binary response
if (nTs == 1){
cat_grm2[cat_grm2==1] <- 0
cat_grm2[cat_grm2==2] <- 1
}
# check response probabilities per replication
res_prob_tb <- NULL
for (item in 1:nvar){
res_prob <- table(cat_grm2[,item])
res_prob_tb <- rbind(res_prob_tb, res_prob)
}
res_prob_tb_WR <- cbind(Rep = r,
item=seq(1,nvar),
res_prob_tb/rowSums(res_prob_tb))
res_prob_tb_BR2 <- rbind(res_prob_tb_BR2, res_prob_tb_WR)
# end checking response probabilities per replication
# write data out per each replication
write.table(cat_grm2,
paste0(file_dir, "/", file_prefix, "_grm2_rep", r, ".dat"),
row.names = FALSE,
col.names = FALSE,
quote = FALSE)
# compile a list of rep names ####
rep_name <- paste0(file_prefix, "_grm2_rep", r, ".dat")
rep_list3 <- rbind(rep_list3, rep_name)
# write it out
write.table(rep_list3,
paste0(file_dir, "/", file_prefix, "_grm_replist.dat"),
row.names = FALSE,
col.names = FALSE,
quote = FALSE)
} # END DATA REPLICATION
# response probability average over all items and replications
last_col <- ncol(res_prob_tb_BR2)
start_col <- 3
x <- res_prob_tb_BR2[,start_col:last_col]
n <- nrow(x)
avg_res_prob <- apply(x, MARGIN = 2, function(x) FUN = sum(x)/n)
# write theta values out ####
write.csv(theta_values,
paste0(file_dir, "/", file_prefix, "_dsrep_theta.csv"),
row.names = FALSE)
model = list(c(1,2,3,4,5, 6, 7),
c(8, 9, 10, 11, 12, 13, 14),
c(15, 16, 17, 18, 19, 20, 21))
model1 = list(c(1,2,3,4,5, 6, 7),
c(8, 9, 10, 11, 12, 13, 14),
c(15, 16, 17, 18, 19, 20, 21))
theta_matrix = theta1$scaled.X
a = a_vec
d = d_vec
N = 300
R = 2
method = "U"
file_dir = getwd()
file_prefix = "test1"
# library(AUTTT)
test1 <- simdata_grm(model = model1,
theta_matrix = theta1$scaled.X,
a = a_vec,
d = d_vec,
N = 300,
R = 2,
method = "U",
file_dir = getwd(),
file_prefix = "test1")
# tools for making an R function
#install.packages('devtools')
library(devtools) # for creating an R package
# tools for documenting your functions
#install.packages('roxygen2')
library(roxygen2) # for documentation
#install.packages("Rdpack")
library("Rdpack") # for adding references
# set project directory
# This is to make sure we work in the right project folder
proj_set("C:/Users/shh6304/Documents/AUTTT", force=FALSE)
# run the function below. #
setwd("C:/Users/shh6304/Documents/AUTTT")
document()
# install from Git
library(devtools)
mytoken <- "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"
install_github("Boklauth/AUTTT", auth_token = mytoken)
model = list(c(1,2,3,4,5, 6, 7),
c(8, 9, 10, 11, 12, 13, 14),
c(15, 16, 17, 18, 19, 20, 21))
model1 = list(c(1,2,3,4,5, 6, 7),
c(8, 9, 10, 11, 12, 13, 14),
c(15, 16, 17, 18, 19, 20, 21))
theta_matrix = theta1$scaled.X
a = a_vec
d = d_vec
N = 300
R = 2
method = "U"
file_dir = getwd()
file_prefix = "test1"
# library(AUTTT)
test1 <- simdata_grm(model = model1,
theta_matrix = theta1$scaled.X,
a = a_vec,
d = d_vec,
N = 300,
R = 2,
method = "U",
file_dir = getwd(),
file_prefix = "test1")
getwd()
getwd()
# library(AUTTT)
setwd("C:/Users/shh6304/Documents/My Documents/test_grm")
test1 <- simdata_grm(model = model1,
theta_matrix = theta1$scaled.X,
a = a_vec,
d = d_vec,
N = 300,
R = 2,
method = "U",
file_dir = getwd(),
file_prefix = "test1")
test1 <- simdata_grm(model = model1,
theta_matrix = theta1$scaled.X,
a = a_vec,
d = d_vec,
N = 300,
R = 2,
method = "U",
file_dir = getwd(),
file_prefix = "test1")
# library(AUTTT)
setwd("C:/Users/shh6304/Documents/My Documents/test_grm")
test1 <- simdata_grm(model = model1,
theta_matrix = theta1$scaled.X,
a = a_vec,
d = d_vec,
N = 300,
R = 2,
method = "U",
file_dir = getwd(),
file_prefix = "test1")
library(AUTTT)
test1 <- simdata_grm(model = model1,
theta_matrix = theta1$scaled.X,
a = a_vec,
d = d_vec,
N = 300,
R = 2,
method = "U",
file_dir = getwd(),
file_prefix = "test1")
model = list(c(1,2,3,4,5, 6, 7),
c(8, 9, 10, 11, 12, 13, 14),
c(15, 16, 17, 18, 19, 20, 21))
model1 = list(c(1,2,3,4,5, 6, 7),
c(8, 9, 10, 11, 12, 13, 14),
c(15, 16, 17, 18, 19, 20, 21))
theta_matrix = theta1$scaled.X
a = a_vec
d = d_vec
N = 300
R = 2
method = "U"
file_dir = getwd()
file_prefix = "test1"
theta_values <- theta_matrix
nTs <- ncol(d) # n of thresholds
# arrange item discrimination in a p x m form,
# p = max n. of items, m = max n. of factors
df <- matrix(rep(0, length(a)), nrow=length(a), ncol=length(model))
param <- a
f <- 1
for (f in 1:length(model)){
start_n <-   min(unlist(model[f]))
end_n <- max(unlist(model[f]))
for (j in start_n : end_n){
df[j,f] <- param[j]
}
}
a_jf <- df
# SIMULATE DATA SET FROM 1 TO R
rep_list3 <- NULL
res_prob_tb_BR2 <- NULL
# convert theta_nf to type of data frame for valid indexing when dim = 1
if(length(model)==1){
theta_nf <- as.data.frame(theta_values)
} else if (length(model)>1){
theta_nf <- theta_values
}
for (r in 1:R){
# data set using probability
# if (sim_methods=="grm2" | sim_methods=="all"){
cat_grm2 <- matrix(rep(0, N*nvar), nrow=N, ncol=nvar)
person <- 1
for (person in 1:N){
x <- matrix(rep(0, nvar*nTs), nrow=nvar, ncol=nTs)
cp_x <- matrix(rep(0, nvar*nTs), nrow=nvar, ncol=nTs)
for (t in 1: nTs){
x[,t] <- (a_jf %*% theta_nf[person,] + d[,t]) # iterate for each threshold for a person
# convert it to cum. probabilities
# per GRM's model (Samejima, 1969) P(x>=0) = 1, P(x >= k+1) = 0
# P(x>=1) > P(x >= 2) >...> P(x >= k)
cp_x[,t] <-  pnorm(x[,t], 0, 1, lower.tail = FALSE) # lower.tail should be FALSE
}
# x_jk (incorporating theta value in the term) for person i
x_jk <- t(x) # will iterate for 1 person and all thresholds and items at a time
# cumulative probabilities for 1 person, all thresholds, and all items
# but I must add the prob. of item category >= k, P(x >= k) = 0
# to avoid error at min(which()) below
cp_x_jk <- t(cbind(cp_x, 0))
# select a probability from a uniform distribution
# approach 1: using U(0,1); i.e., uniform dist. from 0 and 1
if (method == "U"){
q_u <- runif(nvar, 0, 1) # this equals punif(q_u, 0, 1, lower.tail = TRUE)
p <- punif(q_u, 0, 1, lower.tail = FALSE)
} else if (method == "N"){ # approach 2: using N(0,1); i.e., standard normal dist.
q_n <- rep(rnorm(1, 0, 1), nvar)
p <- pnorm(q_n, 0, 1, lower.tail = FALSE)
}
# categorize the underlying variables
for (item in 1: nvar){
cat_grm2[person,item] <- min(which(cp_x_jk[,item] <= p[item]))
}
} # END iterations for all persons
# for binary response
if (nTs == 1){
cat_grm2[cat_grm2==1] <- 0
cat_grm2[cat_grm2==2] <- 1
}
# check response probabilities per replication
res_prob_tb <- NULL
for (item in 1:nvar){
res_prob <- table(cat_grm2[,item])
res_prob_tb <- rbind(res_prob_tb, res_prob)
}
res_prob_tb_WR <- cbind(Rep = r,
item=seq(1,nvar),
res_prob_tb/rowSums(res_prob_tb))
res_prob_tb_BR2 <- rbind(res_prob_tb_BR2, res_prob_tb_WR)
# end checking response probabilities per replication
# write data out per each replication
write.table(cat_grm2,
paste0(file_dir, "/", file_prefix, "_grm2_rep", r, ".dat"),
row.names = FALSE,
col.names = FALSE,
quote = FALSE)
# compile a list of rep names ####
rep_name <- paste0(file_prefix, "_grm2_rep", r, ".dat")
rep_list3 <- rbind(rep_list3, rep_name)
# write it out
write.table(rep_list3,
paste0(file_dir, "/", file_prefix, "_grm_replist.dat"),
row.names = FALSE,
col.names = FALSE,
quote = FALSE)
} # END DATA REPLICATION
# response probability average over all items and replications
last_col <- ncol(res_prob_tb_BR2)
start_col <- 3
x <- res_prob_tb_BR2[,start_col:last_col]
n <- nrow(x)
avg_res_prob <- apply(x, MARGIN = 2, function(x) FUN = sum(x)/n)
# write theta values out ####
write.csv(theta_values,
paste0(file_dir, "/", file_prefix, "_dsrep_theta.csv"),
row.names = FALSE)
simdata_grm
?pnorm
simdata_grm
library(devtools) # for creating an R package
# tools for documenting your functions
#install.packages('roxygen2')
library(roxygen2) # for documentation
#install.packages("Rdpack")
library("Rdpack") # for adding references
# set project directory
# This is to make sure we work in the right project folder
proj_set("C:/Users/shh6304/Documents/AUTTT", force=FALSE)
# run the function below. #
setwd("C:/Users/shh6304/Documents/AUTTT")
document()
